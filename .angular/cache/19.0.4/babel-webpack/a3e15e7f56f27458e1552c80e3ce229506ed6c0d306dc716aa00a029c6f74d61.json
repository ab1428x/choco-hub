{"ast":null,"code":"import { TAG_ID as $, NS, NUMBERED_HEADERS } from '../common/html.js';\n//Element utils\nconst IMPLICIT_END_TAG_REQUIRED = new Set([$.DD, $.DT, $.LI, $.OPTGROUP, $.OPTION, $.P, $.RB, $.RP, $.RT, $.RTC]);\nconst IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = new Set([...IMPLICIT_END_TAG_REQUIRED, $.CAPTION, $.COLGROUP, $.TBODY, $.TD, $.TFOOT, $.TH, $.THEAD, $.TR]);\nconst SCOPING_ELEMENTS_HTML = new Set([$.APPLET, $.CAPTION, $.HTML, $.MARQUEE, $.OBJECT, $.TABLE, $.TD, $.TEMPLATE, $.TH]);\nconst SCOPING_ELEMENTS_HTML_LIST = new Set([...SCOPING_ELEMENTS_HTML, $.OL, $.UL]);\nconst SCOPING_ELEMENTS_HTML_BUTTON = new Set([...SCOPING_ELEMENTS_HTML, $.BUTTON]);\nconst SCOPING_ELEMENTS_MATHML = new Set([$.ANNOTATION_XML, $.MI, $.MN, $.MO, $.MS, $.MTEXT]);\nconst SCOPING_ELEMENTS_SVG = new Set([$.DESC, $.FOREIGN_OBJECT, $.TITLE]);\nconst TABLE_ROW_CONTEXT = new Set([$.TR, $.TEMPLATE, $.HTML]);\nconst TABLE_BODY_CONTEXT = new Set([$.TBODY, $.TFOOT, $.THEAD, $.TEMPLATE, $.HTML]);\nconst TABLE_CONTEXT = new Set([$.TABLE, $.TEMPLATE, $.HTML]);\nconst TABLE_CELLS = new Set([$.TD, $.TH]);\n//Stack of open elements\nexport class OpenElementStack {\n  get currentTmplContentOrNode() {\n    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;\n  }\n  constructor(document, treeAdapter, handler) {\n    this.treeAdapter = treeAdapter;\n    this.handler = handler;\n    this.items = [];\n    this.tagIDs = [];\n    this.stackTop = -1;\n    this.tmplCount = 0;\n    this.currentTagId = $.UNKNOWN;\n    this.current = document;\n  }\n  //Index of element\n  _indexOf(element) {\n    return this.items.lastIndexOf(element, this.stackTop);\n  }\n  //Update current element\n  _isInTemplate() {\n    return this.currentTagId === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;\n  }\n  _updateCurrentElement() {\n    this.current = this.items[this.stackTop];\n    this.currentTagId = this.tagIDs[this.stackTop];\n  }\n  //Mutations\n  push(element, tagID) {\n    this.stackTop++;\n    this.items[this.stackTop] = element;\n    this.current = element;\n    this.tagIDs[this.stackTop] = tagID;\n    this.currentTagId = tagID;\n    if (this._isInTemplate()) {\n      this.tmplCount++;\n    }\n    this.handler.onItemPush(element, tagID, true);\n  }\n  pop() {\n    const popped = this.current;\n    if (this.tmplCount > 0 && this._isInTemplate()) {\n      this.tmplCount--;\n    }\n    this.stackTop--;\n    this._updateCurrentElement();\n    this.handler.onItemPop(popped, true);\n  }\n  replace(oldElement, newElement) {\n    const idx = this._indexOf(oldElement);\n    this.items[idx] = newElement;\n    if (idx === this.stackTop) {\n      this.current = newElement;\n    }\n  }\n  insertAfter(referenceElement, newElement, newElementID) {\n    const insertionIdx = this._indexOf(referenceElement) + 1;\n    this.items.splice(insertionIdx, 0, newElement);\n    this.tagIDs.splice(insertionIdx, 0, newElementID);\n    this.stackTop++;\n    if (insertionIdx === this.stackTop) {\n      this._updateCurrentElement();\n    }\n    this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);\n  }\n  popUntilTagNamePopped(tagName) {\n    let targetIdx = this.stackTop + 1;\n    do {\n      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);\n    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);\n    this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);\n  }\n  shortenToLength(idx) {\n    while (this.stackTop >= idx) {\n      const popped = this.current;\n      if (this.tmplCount > 0 && this._isInTemplate()) {\n        this.tmplCount -= 1;\n      }\n      this.stackTop--;\n      this._updateCurrentElement();\n      this.handler.onItemPop(popped, this.stackTop < idx);\n    }\n  }\n  popUntilElementPopped(element) {\n    const idx = this._indexOf(element);\n    this.shortenToLength(idx < 0 ? 0 : idx);\n  }\n  popUntilPopped(tagNames, targetNS) {\n    const idx = this._indexOfTagNames(tagNames, targetNS);\n    this.shortenToLength(idx < 0 ? 0 : idx);\n  }\n  popUntilNumberedHeaderPopped() {\n    this.popUntilPopped(NUMBERED_HEADERS, NS.HTML);\n  }\n  popUntilTableCellPopped() {\n    this.popUntilPopped(TABLE_CELLS, NS.HTML);\n  }\n  popAllUpToHtmlElement() {\n    //NOTE: here we assume that the root <html> element is always first in the open element stack, so\n    //we perform this fast stack clean up.\n    this.tmplCount = 0;\n    this.shortenToLength(1);\n  }\n  _indexOfTagNames(tagNames, namespace) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      if (tagNames.has(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  clearBackTo(tagNames, targetNS) {\n    const idx = this._indexOfTagNames(tagNames, targetNS);\n    this.shortenToLength(idx + 1);\n  }\n  clearBackToTableContext() {\n    this.clearBackTo(TABLE_CONTEXT, NS.HTML);\n  }\n  clearBackToTableBodyContext() {\n    this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);\n  }\n  clearBackToTableRowContext() {\n    this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);\n  }\n  remove(element) {\n    const idx = this._indexOf(element);\n    if (idx >= 0) {\n      if (idx === this.stackTop) {\n        this.pop();\n      } else {\n        this.items.splice(idx, 1);\n        this.tagIDs.splice(idx, 1);\n        this.stackTop--;\n        this._updateCurrentElement();\n        this.handler.onItemPop(element, false);\n      }\n    }\n  }\n  //Search\n  tryPeekProperlyNestedBodyElement() {\n    //Properly nested <body> element (should be second element in stack).\n    return this.stackTop >= 1 && this.tagIDs[1] === $.BODY ? this.items[1] : null;\n  }\n  contains(element) {\n    return this._indexOf(element) > -1;\n  }\n  getCommonAncestor(element) {\n    const elementIdx = this._indexOf(element) - 1;\n    return elementIdx >= 0 ? this.items[elementIdx] : null;\n  }\n  isRootHtmlElementCurrent() {\n    return this.stackTop === 0 && this.tagIDs[0] === $.HTML;\n  }\n  //Element in scope\n  hasInDynamicScope(tagName, htmlScope) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.tagIDs[i];\n      switch (this.treeAdapter.getNamespaceURI(this.items[i])) {\n        case NS.HTML:\n          {\n            if (tn === tagName) return true;\n            if (htmlScope.has(tn)) return false;\n            break;\n          }\n        case NS.SVG:\n          {\n            if (SCOPING_ELEMENTS_SVG.has(tn)) return false;\n            break;\n          }\n        case NS.MATHML:\n          {\n            if (SCOPING_ELEMENTS_MATHML.has(tn)) return false;\n            break;\n          }\n      }\n    }\n    return true;\n  }\n  hasInScope(tagName) {\n    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);\n  }\n  hasInListItemScope(tagName) {\n    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);\n  }\n  hasInButtonScope(tagName) {\n    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);\n  }\n  hasNumberedHeaderInScope() {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.tagIDs[i];\n      switch (this.treeAdapter.getNamespaceURI(this.items[i])) {\n        case NS.HTML:\n          {\n            if (NUMBERED_HEADERS.has(tn)) return true;\n            if (SCOPING_ELEMENTS_HTML.has(tn)) return false;\n            break;\n          }\n        case NS.SVG:\n          {\n            if (SCOPING_ELEMENTS_SVG.has(tn)) return false;\n            break;\n          }\n        case NS.MATHML:\n          {\n            if (SCOPING_ELEMENTS_MATHML.has(tn)) return false;\n            break;\n          }\n      }\n    }\n    return true;\n  }\n  hasInTableScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {\n        continue;\n      }\n      switch (this.tagIDs[i]) {\n        case tagName:\n          {\n            return true;\n          }\n        case $.TABLE:\n        case $.HTML:\n          {\n            return false;\n          }\n      }\n    }\n    return true;\n  }\n  hasTableBodyContextInTableScope() {\n    for (let i = this.stackTop; i >= 0; i--) {\n      if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {\n        continue;\n      }\n      switch (this.tagIDs[i]) {\n        case $.TBODY:\n        case $.THEAD:\n        case $.TFOOT:\n          {\n            return true;\n          }\n        case $.TABLE:\n        case $.HTML:\n          {\n            return false;\n          }\n      }\n    }\n    return true;\n  }\n  hasInSelectScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {\n        continue;\n      }\n      switch (this.tagIDs[i]) {\n        case tagName:\n          {\n            return true;\n          }\n        case $.OPTION:\n        case $.OPTGROUP:\n          {\n            break;\n          }\n        default:\n          {\n            return false;\n          }\n      }\n    }\n    return true;\n  }\n  //Implied end tags\n  generateImpliedEndTags() {\n    while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {\n      this.pop();\n    }\n  }\n  generateImpliedEndTagsThoroughly() {\n    while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {\n      this.pop();\n    }\n  }\n  generateImpliedEndTagsWithExclusion(exclusionId) {\n    while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {\n      this.pop();\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}